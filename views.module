<?php
// $Id: views.module,v 1.202 2008-01-03 02:50:26 merlinofchaos Exp $

/**
 * @file views.module
 * Query and view site content
 */

/**
 * Register views theming functions.
 */
function views_theme() {
  $path = drupal_get_path('module', 'views');
  include_once "$path/theme/theme.inc";

  // Some quasi clever array merging here.
  $base = array(
    'file' => 'theme.inc',
    'path' => "$path/theme",
  );

  $arguments = array(
    'display' => array('view' => NULL),
    'style' => array('view' => NULL, 'rows' => NULL),
    'row' => array('view' => NULL, 'row' => NULL),
  );

  // Default view themes
  $hooks['views_view'] = $base + array(
    'template' => 'views-view',
    'pattern' => 'views_view__',
    'arguments' => $arguments['display'],
  );
  $hooks['views_view_rows'] = $base + array(
    'template' => 'views-view-rows',
    'pattern' => 'views_view_rows__',
    'arguments' => $arguments['style'],
  );
  $hooks['views_view_row'] = $base + array(
    'template' => 'views-view-row',
    'pattern' => 'views_view_row__',
    'arguments' => $arguments['row'],
  );
  $hooks['views_view_field'] = $base + array(
    'pattern' => 'views_view_field__',
    'arguments' => array('view' => NULL, 'field' => NULL, 'row' => NULL),
  );

  $plugins = views_fetch_plugin_data();

  // Register theme functions for all style plugins
  foreach ($plugins as $type => $info) {
    foreach ($info as $plugin => $def) {
      if (isset($def['theme'])) {
        $hooks[$def['theme']] = array(
          'pattern' => $def['theme'] . '__',
          'file' => $def['file'],
          'path' => $def['path'],
          'arguments' => $arguments[$type],
        );
        if (!function_exists('theme_' . $def['theme'])) {
          $hooks[$def['theme']]['template'] = views_css_safe($def['theme']);
        }
      }
    }
  }

  return $hooks;
}

/**
 * Implementation of hook_menu
 *
 * This probably needs to actually be hook_menu_alter or something.
 */
function views_menu() {
  $items = array();
  foreach (views_get_page_views() as $data) {
    list($view, $display_id) = $data;
    $items += $view->execute_hook_menu($display_id);
  }
  return $items;
}

/**
 * Helper function for menu loading. This will automatically be
 * called in order to 'load' a views argument; primarily it
 * will be used to perform validation.
 *
 * @param $value
 *   The actual value passed.
 * @param $name
 *   The name of the view. This needs to be specified in the 'load function'
 *   of the menu entry.
 * @param $index
 *   The menu argument index. This counts from 1.
 */
function views_arg_load($value, $name, $index) {
  if ($view = views_get_view($name)) {
    $view->init_handlers();
    if (isset($view->argument[$index - 1])) {
      return $view->argument[$index - 1]->handler->validate($value);
    }
  }
}

/**
 * Page callback entry point; requires a view and a display id, then
 * passes control to the display handler.
 */
function views_page() {
  $args = func_get_args();
  $name = array_shift($args);
  $display_id = array_shift($args);

  // Load the view
  if ($view = views_get_view($name)) {
    return $view->execute_display($display_id, $args);
  }

  // Fallback; if we get here no view was found or handler was not valid.
  return drupal_not_found();
}

/**
 * Implementation of hook_block
 */
function views_block($op = 'list', $delta = 0, $edit = array()) {
  switch ($op) {
    case 'list':
      $items = array();
      foreach (views_get_block_views() as $data) {
        list($view, $display_id) = $data;
        $items += $view->execute_hook_block($display_id);
      }
      return $items;
    case 'configure':
    case 'list':
    case 'view':
      list($name, $display_id) = explode('-', $delta);
      // Load the view
      if ($view = views_get_view($name)) {
        if ($op == 'view') {
          return $view->execute_display($display_id, $args);
        }
        else {
          return $view->execute_hook_block($display_id, $op, $delta, $edit);
        }
      }
      break;
  }
}

/**
 * Determine if the given user has access to the view + display.
 */
function views_access($view, $account = NULL) {
  if (is_array($view)) {
    list($name, $display_id) = $view;
    $view = views_get_view($name);
    if (!$view) {
      return FALSE;
    }
    $view->set_display($display_id);
  }

  if (is_string($view)) {
    $view = views_get_view($name);
    if (!$view) {
      return FALSE;
    }
  }

  return $view->access($account);
}

/**
 * Set the current 'page view' that is being displayed so that it is easy
 * for other modules or the theme to identify.
 */
function &views_set_page_view($view = NULL) {
  static $cache = NULL;
  if (isset($view)) {
    $cache = $view;
  }

  return $cache;
}

/**
 * Find out what, if any, page view is currently in use. Please note that
 * this returns a reference, so be careful! You can unintentionally modify the
 * $view object.
 */
function &views_get_page_view() {
  return views_set_page_view();
}

/**
 * Include views .inc files as necessary.
 */
function views_include($file) {
  require_once drupal_get_path('module', 'views') . "/includes/$file.inc";
}

/**
 * Load views files on behalf of modules.
 */
function views_include_handlers() {
  static $finished = FALSE;
  // Ensure this only gets run once.
  if ($finished) {
    return;
  }

  views_include('handlers');
  $views_path = drupal_get_path('module', 'views') . '/modules';
  foreach (module_list() as $module) {
    $module_path = drupal_get_path('module', $module);
    if (file_exists("$module_path/$module.views.inc")) {
      include_once "$module_path/$module.views.inc";
    }
    else if (file_exists("$views_path/$module.views.inc")) {
      include_once "$views_path/$module.views.inc";
    }
  }
  $finished = TRUE;
}

/**
 * Load default views files on behalf of modules.
 */
function views_include_default_views() {
  static $finished = FALSE;
  // Ensure this only gets run once.
  if ($finished) {
    return;
  }

  // Default views hooks may be in the normal handler file,
  // or in a separate views_default file at the discretion of
  // the module author.
  views_include_handlers();

  // Now include the views_default files specifically.
  $views_path = drupal_get_path('module', 'views') . '/modules';
  foreach (module_list() as $module) {
    $module_path = drupal_get_path('module', $module);
    if (file_exists("$module_path/$module.views_default.inc")) {
      include_once "$module_path/$module.views_default.inc";
    }
    else if (file_exists("$views_path/$module.views_default.inc")) {
      include_once "$views_path/$module.views_default.inc";
    }
  }
  $finished = TRUE;
}

/**
 * Fetch Views' data from the cache
 */
function views_fetch_data($table = NULL) {
  static $cache = NULL;
  if (!isset($cache)) {
    $start = microtime();
    // NOTE: This happens whether we retrieve them from cache or otherwise.
    views_include_handlers();

    // @todo: We can probably cache the views_data longer than just the current page run.
    $cache = module_invoke_all('views_data');
    if (module_exists('devel')) {
      dsm('Views data build time: ' . (microtime() - $start) * 1000 . ' ms');
    }
  }

  if (!$table) {
    return $cache;
  }
  if (isset($cache[$table])) {
    return $cache[$table];
  }
  // Return an empty array if there is no match.
  return array();
}

/**
 * Fetch a handler to join one table to a primary table from the data cache
 */
function views_get_table_join($table, $primary_table) {
  $data = views_fetch_data($table);
  if (isset($data['table']['join'][$primary_table])) {
    $h = $data['table']['join'][$primary_table];
    $handler = new $h['handler'];
    if (isset($h['arguments'])) {
      call_user_func_array(array($handler, 'construct'), $h['arguments']);
    }
    return $handler;
  }
  // DEBUG -- identify missing handlers
  dsm("join: $table $primary_table");
}

/**
 * Instantiate and construct a new handler
 */
function _views_create_handler($definition) {
//  dpr('Instantiating handler ' . $definition['handler']);
  $handler = new $definition['handler'];
  if (isset($definition['arguments'])) {
    call_user_func_array(array($handler, 'construct'), $definition['arguments']);
  }

  $handler->set_definition($definition);
  return $handler;
}

/**
 * Prepare a handler's data by checking defaults and such.
 */
function _views_prepare_handler($definition, $data, $field) {
  foreach (array('group', 'title', 'help') as $key) {
    // First check the field level
    if (!isset($definition[$key]) && !empty($data[$field][$key])) {
      $definition[$key] = $data[$field][$key];
    }
    // Then if that doesn't work, check the table level
    if (!isset($definition['table'][$key]) && !empty($data['table'][$key])) {
      $definition[$key] = $data['table'][$key];
    }
  }

  return _views_create_handler($definition);
}

/**
 * Fetch a handler from the data cache.
 */
function views_get_handler($table, $field, $key) {
  $data = views_fetch_data($table);
  if (isset($data[$field][$key])) {
    return _views_prepare_handler($data[$field][$key], $data, $field);
  }
  // DEBUG -- identify missing handlers
  dsm("Missing handler: $table $field $key");
}

/**
 * Builds and return a list of all plugins available in the system.
 *
 * @return Nested array of plugins, grouped by type and
 */
function views_discover_plugins() {
  $cache = array('display' => array(), 'style' => array(), 'row' => array());
  // Get plugins from all mdoules.
  foreach (module_implements('views_plugins') as $module) {
    $function = $module . '_views_plugins';
    $result = $function();
    if (!is_array($result)) {
      continue;
    }
    // Setup automatic path/file finding for theme registration
    if (isset($result['module']) && $result['module'] == 'views') {
      $path = drupal_get_path('module', $module) . '/theme';
      $file = 'theme.inc';
    }
    else {
      $path = drupal_get_path('module', $module);
      $file = "$module.views.inc";
    }
    foreach ($result as $type => $info) {
      if ($type == 'module') {
        continue;
      }
      foreach ($info as $plugin => $def) {
        if (isset($def['theme']) && !isset($def['path'])) {
          $def['path'] = $path;
          $def['file'] = $file;
        }
        // merge the new data in
        $cache[$type][$plugin] = $def;
      }
    }
  }
  return $cache;
}

/**
 * Fetch the plugin data from cache.
 */
function views_fetch_plugin_data($type = NULL, $plugin = NULL) {
  static $cache = NULL;
  if (!isset($cache)) {
    $start = microtime();
    views_include('plugins');
    views_include_handlers();

    $cache = views_discover_plugins();

    if (module_exists('devel')) {
      dsm('Views plugins build time: ' . (microtime() - $start) * 1000 . ' ms');
    }
  }

  if (!$type && !$plugin) {
    return $cache;
  }
  else if (!$plugin) {
    // Not in the if above so the else below won't run
    if (isset($cache[$type])) {
      return $cache[$type];
    }
  }
  else if (isset($cache[$type][$plugin])) {
    return $cache[$type][$plugin];
  }

  // Return an empty array if there is no match.
  return array();
}

/**
 * Get a handler for a plugin
 */
function views_get_plugin($type, $plugin) {
  $definition = views_fetch_plugin_data($type, $plugin);
  if (!empty($definition)) {
    return _views_create_handler($definition);
  }
}

/**
 * Prepare the specified string for use as a CSS identifier.
 */
function views_css_safe($string) {
  return str_replace('_', '-', $string);
}

/**
 * Basic definition for many views objects
 */
class views_object {
  /**
   * Views handlers use a special construct function so that we can more
   * easily construct them with variable arguments.
   */
  function construct() { }

  /**
   * Let the handler know what its full definition is.
   */
  function set_definition($definition) {
    $this->definition = $definition;
    if (isset($definition['field'])) {
      $this->real_field = $definition['field'];
    }
  }
}

/**
 * Get a view from the database or from default views.
 *
 * This function is just a static wrapper around views::load().
 *
 * @todo LG: Shouldn't this be called views_load() to parallel node_load() et al?
 * @param $name
 *   The name of the view.
 * @param $reset
 *   If TRUE, reset this entry in the load cache.
 * @return &$view
 *   A reference to the $view object. Use $reset if you're sure you want
 *   a fresh one.
 */
function &views_get_view($name, $reset = FALSE) {
  views_include('view');
  return view::load($name, $reset);
}

/**
 * Get a view from the default views defined by modules.
 *
 * Default views are cached per-language.  This function will rescan the
 * default_views hook if necessary.
 *
 * @param $view_name
 *  The name of the view to load.
 * @return A view object or NULL if it is not available.
 */
function &views_get_default_view($view_name) {
  static $cache = array();
  global $language;

  // We need to ensure that the view class is defined before we de-serialize the
  // cached view(s), or else it gets cast to a stdClass object.
  views_include('view');

  if (empty($cache[$view_name])) {
    // Try to get the view (for this language) from the cache.
    $view = views_cache_get('views_default_views:'. $view_name, TRUE);

    // If we found the view in the cache, just use that.  If not, try to find it from
    // module hooks.
    if ($view) {
      $cache[$view_name] = $view->data;
    }
    else {
      // We may as well rebuild the cache while we're at it, since we need to pull all
      // of the data anyway.  We pick out the one we want along the way.
      $cache = views_discover_default_views();
    }
  }

  return $cache[$view_name];
}

/**
 * Scan all modules for default views and rebuild the default views cache.
 *
 * @return An associative array of all known default views.
 */
function views_discover_default_views() {
  global $language;
  static $cache = array();

  if (empty($cache)) {
    views_include_default_views();
    $defaults = module_invoke_all('views_default_views');
    foreach ($defaults as $name => $view) {
      if ($should_cache) {
        views_cache_set('views_default_views:'. $name, $view, TRUE);
      }
      $cache[$name] = $view;
    }
  }
  return $cache;
}

/**
 * Set a cached item in the views cache.
 *
 * This is just a convenience wrapper around cache_set().
 *
 * @param $cid
 *   The cache ID of the data to store.
 * @param $data
 *   The data to store in the cache. Complex data types will be automatically serialized before insertion.
 *   Strings will be stored as plain text and not serialized.
 * @param $use_language
 *   If TRUE, the data will be cached specific to the currently active language.
 */
function views_cache_set($cid, $data, $use_language = FALSE) {
  global $language;

  if (variable_get('views_skip_cache', FALSE)) {
    return;
  }
  if ($use_language) {
    $cid .= ':'. $language->language;
  }
  cache_set($cid, $data, 'cache_views');
}

/**
 * Return data from the persistent views cache.
 *
 * This is just a convenience wrapper around cache_get().
 *
 * @param $cid
 *   The cache ID of the data to retrieve.
 * @param $use_language
 *   If TRUE, the data will be requested specific to the currently active language.
 */
function views_cache_get($cid, $use_language = FALSE) {
  global $language;

  if (variable_get('views_skip_cache', FALSE)) {
    return 0;
  }
  if ($use_language) {
    $cid .= ':'. $language->language;
  }

  return cache_get($cid, 'cache_views');
}

/**
 * Implementation of hook_devel_caches().
 *
 * When the devel cache is cleared, clear cached views, too.  That
 * makes development a bit easier.
 */
function views_devel_caches() {
  return array('cache_views');
}

/**
 * Get a list of all views and the display plugins that provide
 * page support to the Drupal menu system. Since views can appear
 * in this list multiple times, the return of this function is an
 * array of arrays.
 *
 * @return
 * @code
 * array(
 *   array($view, $display_id),
 *   array($view, $display_id),
 * );
 */
function views_get_page_views() {
  // First, get all applicable views that are defined in the database.
  views_include('view');
  $views = view::load_views("d.url IS NOT NULL AND d.url <> ''", "INNER JOIN {views_display} d ON v.vid = d.vid");

  // Now get all applicable views that are defined in a default_views hook.
  foreach (views_discover_default_views() as $name => $view) {
    foreach ($view->display as $display) {
      if ($display->display_plugin == 'page') {
        $views[$view->name] = &$view;
        break;
      }
    }
  }

  $result = array();
  foreach ($views as $view) {
    foreach ($view->display as $display) {
      $plugin = views_fetch_plugin_data('display', $display->display_plugin);
      if (!empty($plugin['uses_hook_menu'])) {
        // This view uses hook menu. Clone it so that different handlers
        // don't trip over each other, and add it to the list.
        $v = drupal_clone($view);
        $v->set_display($display->id);
        $result[] = array($v, $display->id);
      }
    }
  }
  return $result;
}

/**
 * Get a list of all views and the display plugins that provide
 * page support to the Drupal menu system. Since views can appear
 * in this list multiple times, the return of this function is an
 * array of arrays.
 *
 * See @see views_get_page_views
 */
function views_get_block_views() {
  // First, get all applicable views.
  views_include('view');
  $views = view::load_views("d.block = 1", "INNER JOIN {views_display} d ON v.vid = d.vid");

  $result = array();
  foreach ($views as $view) {
    $view->init_handlers();
    foreach ($view->display as $display) {
      if ($display->handler && $display->handler->uses_hook_menu) {
        $result[] = array($view, $display->id);
      }
    }
  }
  return $result;
}
