<?php
// $Id: views.module,v 1.205 2008-01-09 00:05:08 merlinofchaos Exp $

/**
 * @file views.module
 *
 * Primarily Drupal hooks and global API functions to manipulate views.
 */

/**
 * Implementation of hook_theme(). Register views theming functions.
 */
function views_theme() {
  $path = drupal_get_path('module', 'views');
  include_once "$path/theme/theme.inc";

  // Some quasi clever array merging here.
  $base = array(
    'file' => 'theme.inc',
    'path' => "$path/theme",
  );

  $arguments = array(
    'display' => array('view' => NULL),
    'style' => array('view' => NULL, 'rows' => NULL),
    'row' => array('view' => NULL, 'row' => NULL),
  );

  // Default view themes
  $hooks['views_view'] = $base + array(
    'template' => 'views-view',
    'pattern' => 'views_view__',
    'arguments' => $arguments['display'],
  );
  $hooks['views_view_rows'] = $base + array(
    'template' => 'views-view-rows',
    'pattern' => 'views_view_rows__',
    'arguments' => $arguments['style'],
  );
  $hooks['views_view_row'] = $base + array(
    'template' => 'views-view-row',
    'pattern' => 'views_view_row__',
    'arguments' => $arguments['row'],
  );
  $hooks['views_view_field'] = $base + array(
    'pattern' => 'views_view_field__',
    'arguments' => array('view' => NULL, 'field' => NULL, 'row' => NULL),
  );

  $plugins = views_fetch_plugin_data();

  // Register theme functions for all style plugins
  foreach ($plugins as $type => $info) {
    foreach ($info as $plugin => $def) {
      if (isset($def['theme'])) {
        $hooks[$def['theme']] = array(
          'pattern' => $def['theme'] . '__',
          'file' => $def['file'],
          'path' => $def['path'],
          'arguments' => $arguments[$type],
        );
        if (!function_exists('theme_' . $def['theme'])) {
          $hooks[$def['theme']]['template'] = views_css_safe($def['theme']);
        }
      }
    }
  }

  return $hooks;
}

/**
 * Implementation of hook_menu().
 *
 * This probably needs to actually be hook_menu_alter or something.
 */
function views_menu() {
  $items = array();
  foreach (views_get_page_views() as $data) {
    list($view, $display_id) = $data;
    $items += $view->execute_hook_menu($display_id);
  }
  return $items;
}

/**
 * Helper function for menu loading. This will automatically be
 * called in order to 'load' a views argument; primarily it
 * will be used to perform validation.
 *
 * @param $value
 *   The actual value passed.
 * @param $name
 *   The name of the view. This needs to be specified in the 'load function'
 *   of the menu entry.
 * @param $index
 *   The menu argument index. This counts from 1.
 */
function views_arg_load($value, $name, $index) {
  if ($view = views_get_view($name)) {
    $view->init_handlers();
    if (isset($view->argument[$index - 1])) {
      return $view->argument[$index - 1]->handler->validate($value);
    }
  }
}

/**
 * Page callback entry point; requires a view and a display id, then
 * passes control to the display handler.
 */
function views_page() {
  $args = func_get_args();
  $name = array_shift($args);
  $display_id = array_shift($args);

  // Load the view
  if ($view = views_get_view($name)) {
    return $view->execute_display($display_id, $args);
  }

  // Fallback; if we get here no view was found or handler was not valid.
  return drupal_not_found();
}

/**
 * Implementation of hook_block
 */
function views_block($op = 'list', $delta = 0, $edit = array()) {
  switch ($op) {
    case 'list':
      $items = array();
      foreach (views_get_block_views() as $data) {
        list($view, $display_id) = $data;
        $items += $view->execute_hook_block($display_id);
      }
      return $items;
    case 'configure':
    case 'list':
    case 'view':
      list($name, $display_id) = explode('-', $delta);
      // Load the view
      if ($view = views_get_view($name)) {
        if ($op == 'view') {
          return $view->execute_display($display_id, $args);
        }
        else {
          return $view->execute_hook_block($display_id, $op, $delta, $edit);
        }
      }
      break;
  }
}

/**
 * Implementation of hook_devel_caches().
 *
 * When the devel cache is cleared, clear cached views, too.  That
 * makes development a bit easier.
 */
function views_devel_caches() {
  return array('cache_views');
}

/**
 * Determine if the given user has access to the view + display.
 *
 * @param $view
 *   May be a view object, or an array with the view name and the display ID,
 *   or a string to use as the view name.
 * @param $account
 *   An optional account to use; if left off, the current user will be used.
 */
function views_access($view, $account = NULL) {
  if (is_array($view)) {
    list($name, $display_id) = $view;
    $view = views_get_view($name);
    if (!$view) {
      return FALSE;
    }
    $view->set_display($display_id);
  }

  if (is_string($view)) {
    $view = views_get_view($name);
    if (!$view) {
      return FALSE;
    }
  }

  return $view->access($account);
}

/**
 * Set the current 'page view' that is being displayed so that it is easy
 * for other modules or the theme to identify.
 */
function &views_set_page_view($view = NULL) {
  static $cache = NULL;
  if (isset($view)) {
    $cache = $view;
  }

  return $cache;
}

/**
 * Find out what, if any, page view is currently in use. Please note that
 * this returns a reference, so be careful! You can unintentionally modify the
 * $view object.
 */
function &views_get_page_view() {
  return views_set_page_view();
}

/**
 * Set the current 'current view' that is being built/rendered so that it is
 * easy for other modules or items in drupal_eval to identify
 */
function &views_set_current_view($view = NULL) {
  static $cache = NULL;
  if (isset($view)) {
    $cache = $view;
  }

  return $cache;
}

/**
 * Find out what, if any, current view is currently in use. Please note that
 * this returns a reference, so be careful! You can unintentionally modify the
 * $view object.
 */
function &views_get_current_view() {
  return views_set_current_view();
}

/**
 * Include views .inc files as necessary.
 */
function views_include($file) {
  static $used = array();
  if (!isset($used[$file])) {
    require_once drupal_get_path('module', 'views') . "/includes/$file.inc";
  }

  $used[$file] = TRUE;
}

/**
 * Load views files on behalf of modules.
 */
function views_include_handlers() {
  static $finished = FALSE;
  // Ensure this only gets run once.
  if ($finished) {
    return;
  }

  views_include('handlers');
  views_include('cache');
  _views_include_handlers();
  $finished = TRUE;
}

/**
 * Load default views files on behalf of modules.
 */
function views_include_default_views() {
  static $finished = FALSE;
  // Ensure this only gets run once.
  if ($finished) {
    return;
  }

  // Default views hooks may be in the normal handler file,
  // or in a separate views_default file at the discretion of
  // the module author.
  views_include_handlers();

  _views_include_default_views();
  $finished = TRUE;
}

/**
 * Fetch a handler from the data cache.
 */
function views_get_handler($table, $field, $key) {
  $data = views_fetch_data($table);
  if (isset($data[$field][$key])) {
    return _views_prepare_handler($data[$field][$key], $data, $field);
  }
  // DEBUG -- identify missing handlers
  dsm("Missing handler: $table $field $key");
}

/**
 * Fetch Views' data from the cache
 */
function views_fetch_data($table = NULL) {
  views_include('cache');
  return _views_fetch_data($table);
}

/**
 * Fetch the plugin data from cache.
 */
function views_fetch_plugin_data($type = NULL, $plugin = NULL) {
  views_include('cache');
  return _views_fetch_plugin_data($type, $plugin);
}

/**
 * Get a handler for a plugin
 */
function views_get_plugin($type, $plugin) {
  $definition = views_fetch_plugin_data($type, $plugin);
  if (!empty($definition)) {
    return _views_create_handler($definition);
  }
}

/**
 * Prepare the specified string for use as a CSS identifier.
 */
function views_css_safe($string) {
  return str_replace('_', '-', $string);
}

/**
 * Get a view from the database or from default views.
 *
 * This function is just a static wrapper around views::load().
 *
 * @todo LG: Shouldn't this be called views_load() to parallel node_load() et al?
 * @param $name
 *   The name of the view.
 * @param $reset
 *   If TRUE, reset this entry in the load cache.
 * @return &$view
 *   A reference to the $view object. Use $reset if you're sure you want
 *   a fresh one.
 */
function &views_get_view($name, $reset = FALSE) {
  views_include('view');
  return view::load($name, $reset);
}

/**
 * Get a view from the default views defined by modules.
 *
 * Default views are cached per-language.  This function will rescan the
 * default_views hook if necessary.
 *
 * @param $view_name
 *  The name of the view to load.
 * @return A view object or NULL if it is not available.
 */
function &views_get_default_view($view_name) {
  $cache = views_discover_default_views();

  if (isset($cache[$view_name])) {
    return $cache[$view_name];
  }
}

/**
 * Scan all modules for default views and rebuild the default views cache.
 *
 * @return An associative array of all known default views.
 */
function views_discover_default_views() {
  static $cache = array();

  if (empty($cache)) {
    views_include('cache');
    $cache = _views_discover_default_views();
  }
  return $cache;
}

/**
 * Get a list of all views and the display plugins that provide
 * page support to the Drupal menu system. Since views can appear
 * in this list multiple times, the return of this function is an
 * array of arrays.
 *
 * @return
 * @code
 * array(
 *   array($view, $display_id),
 *   array($view, $display_id),
 * );
 */
function views_get_page_views() {
  return views_get_applicable_views('uses_hook_menu');
}

/**
 * Get a list of all views and the display plugins that provide
 * themselves to the Drupal block system. Since views can appear
 * in this list multiple times, the return of this function is an
 * array of arrays.
 *
 * @return
 * @code
 * array(
 *   array($view, $display_id),
 *   array($view, $display_id),
 * );
 */
function views_get_block_views() {
  return views_get_applicable_views('uses_hook_block');
}

/**
 * Return a list of all views and display IDs that have a particular
 * setting in their display's plugin settings.
 *
 * @return
 * @code
 * array(
 *   array($view, $display_id),
 *   array($view, $display_id),
 * );
 */
function views_get_applicable_views($type) {
  $result = array();
  $views = views_get_all_views();

  foreach ($views as $view) {
    // Skip disabled views.
    if (!empty($view->disabled)) {
      continue;
    }

    foreach ($view->display as $display) {
      $plugin = views_fetch_plugin_data('display', $display->display_plugin);
      if (!empty($plugin[$type])) {
        // This view uses hook menu. Clone it so that different handlers
        // don't trip over each other, and add it to the list.
        $v = drupal_clone($view);
        $v->set_display($display->id);
        $result[] = array($v, $display->id);
      }
    }
  }
  return $result;
}

/**
 * Return an array of all views as fully loaded $view objects.
 */
function views_get_all_views() {
  static $views = array();

  if (empty($views)) {
    // First, get all applicable views.
    views_include('view');
    $views = view::load_views();

    // Get all default views.
    $status = variable_get('panel_page_defaults', array());

    foreach (views_discover_default_views() as $view) {
      // Determine if default view is enabled or disabled.
      if (isset($status[$view->name])) {
        $view->disabled = $status[$view->name];
      }

      // If overridden, also say so.
      if (!empty($views[$view->name])) {
        $views[$view->name]->type = t('Overridden');
      }
      else {
        $view->type = t('Default');
        $views[$view->name] = $view;
      }
    }

  }
  return $views;
}

/**
 * Basic definition for many views objects
 */
class views_object {
  /**
   * Views handlers use a special construct function so that we can more
   * easily construct them with variable arguments.
   */
  function construct() { }

  /**
   * Let the handler know what its full definition is.
   */
  function set_definition($definition) {
    $this->definition = $definition;
    if (isset($definition['field'])) {
      $this->real_field = $definition['field'];
    }
  }
}
